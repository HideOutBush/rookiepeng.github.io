<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>借钱2 (测试用)</title>
    <url>/2023/11/19/2024/borrow_money_2/</url>
    <content><![CDATA[<p>走在去健身房的路上，突然一短发背着双肩包的男子走了过来。</p>
<p>男子：你好，可以借我十几块钱坐公交吗？我找工作把钱花光了。</p>
<p>我：啊？（我有点懵，为啥这么多人不问，偏偏问我。）</p>
<p>男子看我疑惑的的表情，又复述了一遍刚刚话。</p>
<p>男子：我找工作把钱花光了，可以借我十几块钱坐公交吗？</p>
<p>我：那个，前面100m就是地铁站，要不你去那找工作人员接济一下？</p>
<p>男子低着头往相反方向走了，脸上带着失望。</p>
<p align="right">2020-10-03</p>]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>passerby</tag>
      </tags>
  </entry>
  <entry>
    <title>借钱</title>
    <url>/2020/11/19/2020/11/borror_money/</url>
    <content><![CDATA[<p>走在去健身房的路上，突然一短发背着双肩包的男子走了过来。</p>
<p>男子：你好，可以借我十几块钱坐公交吗？我找工作把钱花光了。</p>
<p>我：啊？（我有点懵，为啥这么多人不问，偏偏问我。）</p>
<p>男子看我疑惑的的表情，又复述了一遍刚刚话。</p>
<p>男子：我找工作把钱花光了，可以借我十几块钱坐公交吗？</p>
<span id="more"></span>

<p>我：那个，前面100m就是地铁站，要不你去那找工作人员接济一下？</p>
<p>男子低着头往相反方向走了，脸上带着失望。</p>
<p align="right">2020-10-03</p>]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>借钱</tag>
        <tag>路人</tag>
      </tags>
  </entry>
  <entry>
    <title>借手机打电话</title>
    <url>/2020/11/19/2020/11/borrow_mobile_phone/</url>
    <content><![CDATA[<p>我在店里吃完肠粉，玩手机时，一小孩走了过来，盯着我的手机看了会。</p>
<p>小孩：叔叔，可以借我你的手机打个电话吗？</p>
<p>我：啊？</p>
<p>小孩：给我妈打个电话，可以吗？</p>
<p>我：哦，可以啊，给！</p>
<span id="more"></span>

<p>小孩拿手机走到另一桌，拨通了他妈的手机号，描述了自己所在的肠粉店。挂断后，小孩拿着手机朝我走了过来。</p>
<p>小孩：谢谢叔叔！</p>
<p>我：不客气！（面带微笑）</p>
<p align="right">2020-10-02</p>]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>社牛小孩</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql字符串字段的字符集不同可能会导致索引不生效</title>
    <url>/2020/11/17/2020/11/mysql_charset_lead_index_fail/</url>
    <content><![CDATA[<p>前言，在探索这个问题之前，我们需要了解 mysql 的一个基本概念。mysql 有三种数据类型，数值型、字符串型、日期型，其中字符串类型需要设置字符集。如果不设置，在创建表结构的时候会默认使用数据库的字符集。</p>
<h3 id="1-准备两个测试表（test-a-test-b）。"><a href="#1-准备两个测试表（test-a-test-b）。" class="headerlink" title="1.准备两个测试表（test_a, test_b）。"></a>1.准备两个测试表（test_a, test_b）。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `test_a` (</span><br><span class="line">  `id` bigint NOT NULL COMMENT &#x27;主键编号&#x27;,</span><br><span class="line">  `test_bigint` bigint DEFAULT NULL COMMENT &#x27;utf8的bigint&#x27;,</span><br><span class="line">  `test_varchar_utf8` varchar(255) DEFAULT NULL COMMENT &#x27;utf8的varchar&#x27;,</span><br><span class="line">  `test_varchar_utf8mb4` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;utf8mb4的varchar&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_test_bigint` (`test_bigint`) USING BTREE COMMENT &#x27;test_bigint索引&#x27;,</span><br><span class="line">  KEY `idx_test_varchar_utf8` (`test_varchar_utf8`) USING BTREE COMMENT &#x27;test_varchar_utf8索引&#x27;,</span><br><span class="line">  KEY `idx_test_varchar_utf8mb4` (`test_varchar_utf8mb4`) USING BTREE COMMENT &#x27;test_varchar_utf8mb4索引&#x27;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `test_b` (</span><br><span class="line">  `id` bigint NOT NULL COMMENT &#x27;主键编号&#x27;,</span><br><span class="line">  `test_bigint` bigint DEFAULT NULL COMMENT &#x27;utf8的bigint&#x27;,</span><br><span class="line">  `test_varchar_utf8` varchar(255) DEFAULT NULL COMMENT &#x27;utf8的varchar&#x27;,</span><br><span class="line">  `test_varchar_utf8mb4` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;utf8的varchar&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_test_bigint` (`test_bigint`) USING BTREE COMMENT &#x27;test_bigint索引&#x27;,</span><br><span class="line">  KEY `idx_test_varchar_utf8` (`test_varchar_utf8`) USING BTREE COMMENT &#x27;test_varchar_utf8索引&#x27;,</span><br><span class="line">  KEY `idx_test_varchar_utf8mb4` (`test_varchar_utf8mb4`) USING BTREE COMMENT &#x27;test_varchar_utf8mb4索引&#x27;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>注意：这两个表的 test_varchar_utf8 字段使用的是utf8字符集，test_varchar_utf8mb4 字段使用的是 utf8mb4 字符集。mysql 的 utf8 使用最大3字节长度来编码字符，而 utf8mb4 是使用最大4字节长度编码字符，可以理解为 utf8mb4 是 utf8 的超集。</strong></p>
<h3 id="2-插入几条测试数据"><a href="#2-插入几条测试数据" class="headerlink" title="2.插入几条测试数据"></a>2.插入几条测试数据</h3><p>在 test_a 表中插入一条数据，在 test_b 表中插入10条数据。多少条数据无所谓，只需要能达到测试效果即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO `test_a`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (1, 1, &#x27;1&#x27;, &#x27;1&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (1, 1, &#x27;1&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (2, 2, &#x27;2&#x27;, &#x27;2&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (3, 3, &#x27;3&#x27;, &#x27;3&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (4, 4, &#x27;4&#x27;, &#x27;4&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (5, 5, &#x27;5&#x27;, &#x27;5&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (6, 6, &#x27;6&#x27;, &#x27;6&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (7, 7, &#x27;7&#x27;, &#x27;7&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (8, 8, &#x27;8&#x27;, &#x27;8&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (9, 9, &#x27;9&#x27;, &#x27;9&#x27;);</span><br><span class="line">INSERT INTO `test_b`(`id`, `test_bigint`, `test_varchar_utf8`, `test_varchar_utf8mb4`) VALUES (10, 10, &#x27;10&#x27;, &#x27;10&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="3-准备测试的-sql-语句，并执行"><a href="#3-准备测试的-sql-语句，并执行" class="headerlink" title="3.准备测试的 sql 语句，并执行"></a>3.准备测试的 sql 语句，并执行</h3><p>通过 test_a 表的数据关联查询 test_b 表的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 测试非字符串类型的查询</span><br><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON tb.test_bigint = ta.test_bigint WHERE ta.test_bigint = 1;</span><br><span class="line">-- 测试字符串类型，使用utf8编码的字段查询utf8编码的字段</span><br><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON tb.test_varchar_utf8 = ta.test_varchar_utf8 WHERE ta.test_varchar_utf8 = &#x27;1&#x27;;</span><br><span class="line">-- 测试字符串类型，使用utf8mb4编码的字段查询utf8编码的字段</span><br><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON tb.test_varchar_utf8 = ta.test_varchar_utf8mb4 WHERE ta.test_varchar_utf8 = &#x27;1&#x27;;</span><br><span class="line">-- 测试字符串类型，使用utf8编码的字段查询utf8mb4编码的字段</span><br><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON tb.test_varchar_utf8mb4 = ta.test_varchar_utf8 WHERE ta.test_varchar_utf8 = &#x27;1&#x27;;</span><br><span class="line">-- 测试字符串类型，使用utf8mb4编码的字段查询utf8mb4编码的字段</span><br><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON tb.test_varchar_utf8mb4 = ta.test_varchar_utf8mb4 WHERE ta.test_varchar_utf8 = &#x27;1&#x27;;</span><br></pre></td></tr></table></figure>
<p>以下是执行结果</p>
<p><strong>结果1：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/d5d1c78846aa4832882f2e75b5523f2e.png" alt="图 3-1.png"><br><strong>结果2：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/8ce85144b90144a3b63cf31b33281692.png" alt="图 3-2.png"><br><strong>结果3：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/f70177102e47452c93de9664b78059aa.png" alt="图 3-3.png"><br><strong>结果4：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/9638030ad8374fd8b8e62c7cbb062b2a.png" alt="图 3-4.png"><br><strong>结果5：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/d07ae072b3814f7b9ae80163779130f9.png" alt="图 3-5.png"></p>
<h3 id="4-分析执行结果"><a href="#4-分析执行结果" class="headerlink" title="4.分析执行结果"></a>4.分析执行结果</h3><h5 id="4-1-对于-table-ta-的查询始终是走索引的"><a href="#4-1-对于-table-ta-的查询始终是走索引的" class="headerlink" title="4-1.对于 table ta 的查询始终是走索引的"></a>4-1.对于 table ta 的查询始终是走索引的</h5><p>观察5个结果中 table ta 的 key 字段，都是有值的。这说明了在使用 where 条件显式查询时，不管目标字段的字符集是什么，都会在查询的过程中默认使用该字符集进行编译，然后就可以走索引。</p>
<h5 id="4-2-对于-table-tb-的查询，会因为字符集的不同导致不走索引"><a href="#4-2-对于-table-tb-的查询，会因为字符集的不同导致不走索引" class="headerlink" title="4-2.对于 table tb 的查询，会因为字符集的不同导致不走索引"></a>4-2.对于 table tb 的查询，会因为字符集的不同导致不走索引</h5><p>观察5个结果中的 table tb 的 key 字段，只有结果3的 key 字段为 null，再看看结果3的查询语句，使用 utf8mb4 编码的字段查询 utf8 编码的字段，联想开篇提到的内容，utf8mb4 是 utf8 的超集，那我们使用 utf8mb4 编码的字段去查询 utf8 编码的字段会出现不兼容的情况，没法走索引。</p>
<h5 id="4-3-对于-table-tb-的查询，如果目标字段的字符集可以兼容源字段的字符集，还是可以走索引。"><a href="#4-3-对于-table-tb-的查询，如果目标字段的字符集可以兼容源字段的字符集，还是可以走索引。" class="headerlink" title="4-3. 对于 table tb 的查询，如果目标字段的字符集可以兼容源字段的字符集，还是可以走索引。"></a>4-3. 对于 table tb 的查询，如果目标字段的字符集可以兼容源字段的字符集，还是可以走索引。</h5><p>观察第4条 sql 语句，使用 utf8 编码的字段查询 utf8mb4 编码的字段，再看它的执行结果，table tb的 key 字段是有值的，代表走了索引，联想开篇提到的内容，utf8mb4 是 utf8 的超集，那么就可以理解为啥字符集不同也可以走索引了。</p>
<h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h3><p>mysql 字符串字段的字符集不同可能会导致索引不生效</p>
<h3 id="6-建议"><a href="#6-建议" class="headerlink" title="6.建议"></a>6.建议</h3><p>为了方便使用，还是统一数据库字符集比较好。<br>如果没法修改字段的字符集的话，也可以使用强转字符集的方式，让字段走索引。我们将第3条sql语句按照下面的方式进行调整。</p>
<h5 id="6-1-将-utf8-强转成-utf8mb4，不走索引"><a href="#6-1-将-utf8-强转成-utf8mb4，不走索引" class="headerlink" title="6-1.将 utf8 强转成 utf8mb4，不走索引"></a>6-1.将 utf8 强转成 utf8mb4，不走索引</h5><p>将 utf8 强转成 utf8mb4 时，需要设置字符集的排序规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON CONVERT(tb.test_varchar_utf8 USING utf8mb4) COLLATE utf8mb4_general_ci = ta.test_varchar_utf8mb4 WHERE ta.test_varchar_utf8mb4 = &#x27;1&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果如下：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/7c6fd6a54f3c4024bf636d31e263d1cc.png" alt="图 6-1.png"><br>从图 6-1中可以看到，table tb 的 key 字段的值为 null，代表它没走索引。也就是说，将 utf8 强转成 utf8mb4，并不会走索引。</p>
<h5 id="6-2-将-utf8mb4-强转成-utf8，走索引"><a href="#6-2-将-utf8mb4-强转成-utf8，走索引" class="headerlink" title="6-2.将 utf8mb4 强转成 utf8，走索引"></a>6-2.将 utf8mb4 强转成 utf8，走索引</h5><p>将 utf8mb4 强转成 utf8 时，不需要设置字符集的排序规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 测试字符串类型，通过utf8mb4查询utf8，将utf8mb4强转成utf8</span><br><span class="line">EXPLAIN SELECT * FROM test_a ta INNER JOIN test_b tb ON tb.test_varchar_utf8 = CONVERT(ta.test_varchar_utf8mb4 USING utf8) WHERE ta.test_varchar_utf8mb4 = &#x27;1&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果如下：</strong><br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/f4e77a4a665845468e22db0a871209da.png" alt="图 6-2.png"><br>从图 6-2中可见，table tb 的 key 字段是有值的，这代表它走了索引，完结撒花！</p>
]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>git bash配置代理</title>
    <url>/2020/11/19/2020/11/git_bash_proxy/</url>
    <content><![CDATA[<h3 id="1-https加速"><a href="#1-https加速" class="headerlink" title="1.https加速"></a>1.https加速</h3><h5 id="1-1-当代理为http或https时"><a href="#1-1-当代理为http或https时" class="headerlink" title="1-1.当代理为http或https时"></a>1-1.当代理为http或https时</h5><p>1080为代理端口号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h5 id="1-2-当代理为ss或ssr时"><a href="#1-2-当代理为ss或ssr时" class="headerlink" title="1-2.当代理为ss或ssr时"></a>1-2.当代理为ss或ssr时</h5><p>注意，得确认自己的代理使用的是哪个协议，哪个端口，比如我的就是 socks5 和 1080，以及端口号。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="1-3-重置代理"><a href="#1-3-重置代理" class="headerlink" title="1-3.重置代理"></a>1-3.重置代理</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h3 id="2-ssl加速"><a href="#2-ssl加速" class="headerlink" title="2.ssl加速"></a>2.ssl加速</h3><p>在用户文件夹下，打开&#x2F;.ssh&#x2F;config文件（如果没有就自己创建一个），输入以下内容。其中 id_rsa 文件需要换成你的文件，端口号 1080 也需要换成你的代理端口号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Port 443</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">IdentityFile ~\.ssh\id_rsa</span><br><span class="line">TCPKeepAlive yes</span><br><span class="line">ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure>
<p>如果使用Socks5代理，这时候测试可能会出现以下报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL: Cannot get password for user:xxx</span><br></pre></td></tr></table></figure>
<p>原因是代理需要密码，需要设置一个环境变量SOCKS5_PASSWD。如果你的代理里没有设置用户名和密码的话随便填即可。<br>比如我的：<br><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2020/11/27260163e0ca42359660bc6c768963ac.png" alt="图 2-1.png"></p>
]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>一次巧合——梦境与现实</title>
    <url>/2024/02/27/2024/02/a_coincidence/</url>
    <content><![CDATA[<p>有一天晚上，做了一个很奇怪的梦，梦到了一个球友脚崴了，然后我背着他走了一段路。</p>
<p>接着我忍不住问他，你对象呢，她怎么不来接你。</p>
<p>他沉默了，默默的走开了。</p>
<p>梦醒了，很平淡的一个梦。</p>
<p>第二天，正在上班，突然这个球友发消息来问我有没有什么 AI 工具推荐，当即把 GPT4 推荐给他。</p>
<p><strong>巧合点：</strong></p>
<ul>
<li>上次和这个球友聊天是20天之前，并且那天晚上思想中没有出现过这个球友的任何事情。</li>
<li>梦到之后，第二天竟然碰到他发消息过来。</li>
</ul>
]]></content>
      <categories>
        <category>巧合</category>
      </categories>
      <tags>
        <tag>巧合</tag>
        <tag>梦境与现实</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 WildCard 开通 GPT4 (Use WildCard to Subscribe GPT4)</title>
    <url>/2024/01/28/2024/01/use_wildcard_to_subscribe_gpt4/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>今天逛知乎时，突然看到有个文章，说有两种方法可以开通 GPT4。</p>
<ul>
<li>使用 Apple App Store 可以开通 GPT4，但是新用户没法开通，因为不开放这个入口了。</li>
<li>使用 WildCard 可以开通 GPT4。</li>
</ul>
<p>抱着试一试的心态，尝试了下 WildCard，真的开通成功了。</p>
<h1 id="如何开通"><a href="#如何开通" class="headerlink" title="如何开通"></a>如何开通</h1><p><strong>注意：开卡需要支付一定的费用，并且需要支付一定的手续费，请一定考虑清楚。</strong></p>
<p>接下来简单介绍一下使用 WildCard 开通 GPT4 的过程。</p>
<span id="more"></span>

<ol>
<li><p>先来到<a href="https://bewildcard.com/i/PENG244"> WildCard 的官网 </a>( <a href="https://bewildcard.com/i/PENG244">https://bewildcard.com/i/PENG244</a> )。</p>
<p> <img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website.png" alt="图 1 WildCard 官网.png"></p>
</li>
<li><p>点击 <strong>Started</strong> 按钮。</p>
<p> <img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website-ClickStarted.png" alt="图 2 ClickStarted.png"></p>
</li>
<li><p>来到开卡页面，点击 <strong>I understand, open card now</strong> 按钮。</p>
<p> <img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website-OpenCardNow.png" alt="图 3 OpenCardNow.png"></p>
</li>
<li><p>来到手机号注册页面，这里的邀请码（Invitation Code）可以写我的这个（<strong>PENG244</strong>），感谢。注册完之后还需要使用支付宝进行人脸识别，设置登录密码、支付密码，最后支付开卡费用。</p>
<p> <img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website-EnterYourPhoneNumber.png" alt="图 4 EnterYourPhoneNumber.png"></p>
</li>
<li><p>如果已经注册完，并且开好卡了，按照以下图中步骤来到升级 GPT4 的页面。</p>
<p><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website-UpgradeChatGPT.png" alt="图 5 UpgradeChatGPT.png"></p>
</li>
<li><p>注意看提示信息，最好别使用微软邮箱，风险高，很容易被封号，封号了钱是不给退的。如果邮箱符合要求则点击 <strong>My email account meets the requirements</strong> 按钮。<br>否则，要么使用一个符合要求的邮箱去注册新的 openai 账号；要么点击 <strong>Recommended Overseas Email Registration</strong> 按钮，然后使用 WildCard 推荐的海外邮箱去一键注册并开通 ChatGPT4。</p>
<p><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website-AvoidEmail.png" alt="图 6 AvoidEmail.png"></p>
</li>
<li><p>先充值至少 20 美元到 WildCard 账户（注意，这里的充值也是要收手续费的），按照下图中的步骤，点击 ChatGPT 中的 <strong>Upgrade</strong> 按钮，选择 <strong>Upgrade Plan</strong>。<br>来到付款页面后，将付款页面的链接全选复制，并粘贴到 WildCard 的 <strong>Confirm</strong> 按钮上方的输入框中。顺利的话，等个 3-5 分钟，GPT4 就开通成功了，如果开通失败的话，钱是不会花掉，换个新的 openai 账号再试试，祝君成功。</p>
<p><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/WildCard-Official-Website-FollowStepToUpgrade.png" alt="图 7 FollowStepToUpgrade.png"></p>
</li>
<li><p>最后给大家看看我的 openai 账号。</p>
<p><img src="https://blog-bruceboron.oss-cn-shenzhen.aliyuncs.com/github/pages/2024/01/openai-GPT4.png" alt="图 8 FollowStepToUpgrade.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>openai</category>
      </categories>
      <tags>
        <tag>GPT4</tag>
        <tag>openai</tag>
        <tag>WildCard</tag>
      </tags>
  </entry>
  <entry>
    <title>前司领导找我要本司的产品设计方案 哈哈 若只</title>
    <url>/2024/01/16/2024/01/ask_product_design_scheme/</url>
    <content><![CDATA[<p>在一个平平无奇的早上，我一边摸着鱼，一边整理着需求。</p>
<p>忽然，有个前同事发消息过来，说前领导找我要本司的部分<strong>产品设计方案</strong>和<strong>产品研发流程</strong>。</p>
<p>（是的，我都没有前领导的好友，前领导通过前同事联系的我。）</p>
<span id="more"></span>

<p>俺寻思着，你 tm 秀逗了吧，老子跟你关系有这么好吗，凭啥给你啊，你又没给老子发工资。真是乌龟办走读，憋（鳖）不住笑（校）了。</p>
<p>本着不撕破脸的原则，我回了个“简单的很”。</p>
<p>前同事一眼就明白了拒绝的意思，并传话给前领导。前领导仿佛听不懂人话，丝毫看不出拒绝，问我能不能快点给，还蹬鼻子上脸说<strong>顺便录个视频吧</strong>。</p>
<p>真 tm 笑死，老子回你一句，你还真把自己当根葱了啊？蝙蝠上插鸡毛——你算什么鸟啊？一点 b 数都没有。</p>
<p>几十号人的研发团队，这点事都做不到吗，就你这 b 样，也能混成领导？哪凉快哪待着去，别来恶心老子。</p>
<p>老子当初一个人干几个人的活，也没给几个钱，现在还想白嫖老子，你是若只吗？滚！！！有多远滚多远！</p>
<p>(本故事改编自真实事件，来自一位朋友)</p>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>离谱</tag>
        <tag>产品</tag>
        <tag>前领导</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义国际化功能</title>
    <url>/2021/07/15/2021/07/customize_i18n/</url>
    <content><![CDATA[<p>国际化的定义各不相同。这是用于 W3C 国际化活动材料的高级工作定义。有些人使用其他术语（例如全球化）来指代同一概念。<br>国际化是产品、应用程序或文档内容的设计和开发，它可以为不同文化、地区或语言的目标受众轻松本地化。<br>国际化（Internationalization）通常用英文写成i18n，其中 18 是英文单词中i和n之间的字母数。<sup>[1]</sup></p>
<p>本文主要基于java针对语言国际化进行阐述。</p>
<p>任何一个面向全世界的软件都会面临多语言国际化的问题，对于java web应用，要实现国际化功能，就是在数据展示给用户之前，替换成对应的语言。</p>
<span id="more"></span>

<h3 id="1-使用spring自带的i18n（国际化）"><a href="#1-使用spring自带的i18n（国际化）" class="headerlink" title="1.使用spring自带的i18n（国际化）"></a>1.使用spring自带的i18n（国际化）</h3><p>这个比较简单，在网上找一找到处都是教程，这里将会手动配置一次spring i18n国际化来介绍一下。<br>以下是笔者使用的spring boot版本号.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-在properties或yml资源文件里面配置i18n"><a href="#1-1-在properties或yml资源文件里面配置i18n" class="headerlink" title="1-1.在properties或yml资源文件里面配置i18n"></a>1-1.在properties或yml资源文件里面配置i18n</h5><p>笔者用的是yml文件，可以自行转换成properties文件格式。</p>
<ul>
<li><strong>basename：</strong>以逗号分隔的基名列表(本质上是一个完全限定的类路径位置)，每个基名都遵循ResourceBundle约定，对基于斜杠的位置提供宽松的支持。 如果它不包含包限定符(例如“org.mypackage”)，它将从类路径根目录解析。</li>
<li><strong>cache-duration：</strong>加载的资源包文件缓存持续时间。 如果没有设置，捆绑包将被永久缓存。 如果没有指定持续时间后缀，将使用秒。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># i18n</span><br><span class="line">spring:</span><br><span class="line">  messages:</span><br><span class="line">    basename: i18n/messages</span><br><span class="line">    cache-duration: 60</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="1-2-在resources文件夹下新增i18n文件夹，并新建相应的国际化文件"><a href="#1-2-在resources文件夹下新增i18n文件夹，并新建相应的国际化文件" class="headerlink" title="1-2.在resources文件夹下新增i18n文件夹，并新建相应的国际化文件"></a>1-2.在resources文件夹下新增i18n文件夹，并新建相应的国际化文件</h5><p>spring容器启动的时候，会根据配置的basename去对应的路径加载资源文件到MessageSource里，至于是怎么加载到MessageSource里的，在这里就不展开阐述了。</p>
<p>文件配置如图 1-1所示。</p>
<p><strong>注意：红色框 里的就是i18n资源文件的配置，绿色框 是idea自动生成的文件夹，实际并不存在，无视就行。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7316408-709b2c3aab575f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 1-1  i18n资源文件.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># messages.properties</span><br><span class="line">test.name=test rookie0peng</span><br><span class="line">test.string=test string &#123;0&#125;</span><br><span class="line">test.date=test date &#123;0, date&#125;</span><br><span class="line">test.time=test time &#123;0, time&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># messages_en.properties</span><br><span class="line">test.name=test rookie0peng</span><br><span class="line">test.string=test string &#123;0&#125;</span><br><span class="line">test.date=test date &#123;0, date&#125;</span><br><span class="line">test.time=test time &#123;0, time&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># messages_zh.properties</span><br><span class="line">test.name=测试阿鹏</span><br><span class="line">test.string=测试字符串&#123;0&#125;</span><br><span class="line">test.date=测试日期&#123;0, date&#125;</span><br><span class="line">test.time=测试时间&#123;0, time&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-在代码中使用i18n进行国际化"><a href="#1-3-在代码中使用i18n进行国际化" class="headerlink" title="1-3.在代码中使用i18n进行国际化"></a>1-3.在代码中使用i18n进行国际化</h5><p>这里演示的是比较简单的手动参数替换，还有更好一些的方法，比如说在响应数据写入流的时候进行参数替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;test&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;随便打印数据&quot;)</span><br><span class="line">    @RequestMapping(path = &quot;console&quot;, method = RequestMethod.POST)</span><br><span class="line">    public Map&lt;String, String&gt; console() &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //1.测试无参替换</span><br><span class="line">        map.put(&quot;test.name&quot;, messageSource.getMessage(&quot;test.name&quot;, null, LocaleContextHolder.getLocale()));</span><br><span class="line">        //2.测试字符串参数替换</span><br><span class="line">        Object[] stringParam = new Object[] &#123;&quot;1&quot;&#125;;</span><br><span class="line">        map.put(&quot;test.string&quot;, messageSource.getMessage(&quot;test.string&quot;, stringParam, LocaleContextHolder.getLocale()));</span><br><span class="line">        //3.测试日期参数替换</span><br><span class="line">        Object[] dateParam = new Object[] &#123;new Date()&#125;;</span><br><span class="line">        map.put(&quot;test.date&quot;, messageSource.getMessage(&quot;test.date&quot;, dateParam, LocaleContextHolder.getLocale()));</span><br><span class="line">        //3.测试时间参数替换</span><br><span class="line">        Object[] timeParam = new Object[] &#123;new Date()&#125;;</span><br><span class="line">        map.put(&quot;test.time&quot;, messageSource.getMessage(&quot;test.time&quot;, timeParam, LocaleContextHolder.getLocale()));</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-测试spring-i18n"><a href="#1-4-测试spring-i18n" class="headerlink" title="1-4.测试spring i18n"></a>1-4.测试spring i18n</h5><p>启动项目后，查看调用**&#x2F;test&#x2F;console**接口返回的数据，调用三次，分别设置header中的语言：默认、中文、英文。<br>笔者用的是idea的HTTP Client，以下是请求参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 默认——测试spring i18n</span><br><span class="line">POST &#123;&#123;baseUrl&#125;&#125;/test/console</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 中文——测试spring i18n</span><br><span class="line">POST &#123;&#123;baseUrl&#125;&#125;/test/console</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 英文——测试spring i18n</span><br><span class="line">POST &#123;&#123;baseUrl&#125;&#125;/test/console</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept-Language: en;q=0.9</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是响应参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;test.name&quot;: &quot;测试阿鹏&quot;,</span><br><span class="line">  &quot;test.string&quot;: &quot;测试字符串1&quot;,</span><br><span class="line">  &quot;test.date&quot;: &quot;测试日期2021年7月3日&quot;,</span><br><span class="line">  &quot;test.time&quot;: &quot;测试时间下午4:41:27&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;test.name&quot;: &quot;测试阿鹏&quot;,</span><br><span class="line">  &quot;test.string&quot;: &quot;测试字符串1&quot;,</span><br><span class="line">  &quot;test.date&quot;: &quot;测试日期2021年7月3日&quot;,</span><br><span class="line">  &quot;test.time&quot;: &quot;测试时间下午4:41:27&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;test.name&quot;: &quot;test rookie0peng&quot;,</span><br><span class="line">  &quot;test.string&quot;: &quot;test string 1&quot;,</span><br><span class="line">  &quot;test.date&quot;: &quot;test date Jul 3, 2021&quot;,</span><br><span class="line">  &quot;test.time&quot;: &quot;test time 4:41:32 PM&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-分析执行结果"><a href="#1-5-分析执行结果" class="headerlink" title="1-5.分析执行结果"></a>1-5.分析执行结果</h5><ul>
<li>1-5-1.<strong>测试默认</strong>和<strong>测试中文</strong>的响应数据是一样的，可以确定系统默认使用的中文环境。</li>
<li>1-5-2.调用getMessage()方法时，不传第2个参数就是无参替换；否则，反之。</li>
<li>1-5-3.使用有参替换时，还可以在properties文件里加入date、time等参数，spring可以自动格式化成对应的日期和时间。</li>
</ul>
<h5 id="1-6-结论"><a href="#1-6-结论" class="headerlink" title="1-6.结论"></a>1-6.结论</h5><p>这里只是简单的演示了spring i18n的功能，对于一些简单的场景已然满足需要，如果需要进行扩展的话，有几种思路。</p>
<ul>
<li>1-6-1.如果使用了nacos等配置中心，则需要去注册中心手动拉取i18n的properties文件内容，并加载到应用程序的内存里，也可以在本地用户文件夹存放一份。</li>
<li>1-6-2.如果需要一些正则翻译的话，则需要自己动手写正则替换的表达式。</li>
<li>1-6-3.该例子展示的是在controller里进行替换，更好一点的方式是在filter，甚至是在响应数据写入流的时候进行替换，比如说指定某个响应对象的某个属性的序列化类（@JsonSerialize(using &#x3D; TestJsonSerializer.class)），则该字段序列化的时候就会使用TestJsonSerializer.class进行序列化。在这个类里面就可以针对性的做我们想要的替换了。</li>
</ul>
<h3 id="2-自定义i18n"><a href="#2-自定义i18n" class="headerlink" title="2.自定义i18n"></a>2.自定义i18n</h3><p>spring i18n是挺好用的，但是面对复杂的业务需求，还不够强大。比如，用户想添加一种语言；递归替换；布局可以自定义，用户添加布局字段时，针对该项目或组织的不同地区的人员，设置不同的翻译内容等等。</p>
<p>基于各种各样的原因，扩展i18n已是必须要做的事。</p>
<p>那么怎么扩展呢？国际化的本质就是将key替换成不同语言的value，这句话中有几个关键点：key、替换、语言、value。其中<strong>key</strong>、<strong>语言</strong>、<strong>value</strong>都是名词，代表着具体的数据；<strong>替换</strong>是动词，代表具体的翻译逻辑。那我们就需要针对这几个点进行设计与实现。</p>
<h5 id="2-1-设计数据表"><a href="#2-1-设计数据表" class="headerlink" title="2-1.设计数据表"></a>2-1.设计数据表</h5><p>思路：通过一种语言和键找到对应的值。表结构设计比较简单，key、value、语言各建一个表，如图 2-1所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7316408-440df83c13f12bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2-1  国际化表结构设计.png"></p>
<p>其中每个表只展示了主键编号字段，其实还有一些字段没展示出来，比如code、name，这些可以根据自己的风格去设计。如果是多租户的系统，在每张表后面加入对应的租户id，即可进行数据隔离。</p>
<ul>
<li>2-1-1.如果用户新增的字段需要翻译，往<strong>语言键</strong>里增加一条数据，以及往<strong>语言值</strong>里增加与<strong>语言定义</strong>相同数量的记录即可。</li>
<li>2-1-2.如果用户新增<strong>语言定义</strong>，则往<strong>语言值</strong>里面增加与<strong>语言键</strong>相同数量的记录即可。</li>
<li>2-1-3.更新、删除同理。</li>
</ul>
<h5 id="2-2-数据缓存设计"><a href="#2-2-数据缓存设计" class="headerlink" title="2-2.数据缓存设计"></a>2-2.数据缓存设计</h5><p>在一个面向世界的应用里面，翻译的频率是很高的，而且随着时间的流逝，翻译的数据肯定会越来越多，如果每次响应数据的翻译都去查询数据库的话，那势必会造成数据库性能以及应用本身性能的浪费。对于这种修改频率不算高的数据，咱们可以缓存起来，用空间换时间。</p>
<p>这里打算用两级缓存的设计来适应该翻译场景，一级是redis，二级是应用内存。</p>
<ul>
<li>2-2-1.将用到的数据从数据库缓存在redis里面，并且生成一个更新标志放入redis。</li>
<li>2-2-2.应用获取翻译数据的时候先判断redis更新标志是否为空。<ul>
<li>2-2-2-1.为空，则代表redis尚未缓存翻译数据，将翻译数据从数据库拉取到内存，且推送到redis。</li>
<li>2-2-2-2.不为空，则代表redis已缓存翻译数据，然后再比对redis的更新标志和应用内存的更新标志是否一致。<ul>
<li>2-2-2-2-1.不一致，则说明翻译数据已经改变，需要从redis重新拉取一次翻译数据，缓存在应用内存中。</li>
<li>2-2-2-2-2.一致，则说明翻译数据尚未改变，可以直接使用应用内存中的翻译数据。</li>
</ul>
</li>
</ul>
</li>
<li>2-2-3.将最后拿到的翻译数据（key-value）返回给实现翻译逻辑的组件。</li>
</ul>
<p>如图 2-2所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7316408-da3da3c43add31a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2-2  国际化两级缓存设计.png"></p>
<p>代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  @description: 语言数据组件</span><br><span class="line"> *  @author: rookie0peng</span><br><span class="line"> *  @date: 2021/7/4 21:28</span><br><span class="line"> *  &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">public interface LanguageDataComponent &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过语言定义和键获取值</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @return optional -&gt; 值</span><br><span class="line">     */</span><br><span class="line">    Optional&lt;String&gt; getValue(String definition, String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新语言键值对映射</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     */</span><br><span class="line">    void updateKeyValueMap(String definition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service(&quot;languageDataComponent&quot;)</span><br><span class="line">public class LanguageDataComponentImpl implements LanguageDataComponent &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 语言定义 -&gt; (key, value)</span><br><span class="line">     */</span><br><span class="line">    private static final Map&lt;String, Map&lt;String, String&gt;&gt; DEFINITION_TO_KEY_VALUE_MAP = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一天</span><br><span class="line">     */</span><br><span class="line">    private static final long ONE_DAY = 86400;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新标志</span><br><span class="line">     */</span><br><span class="line">    private static final String CHANGE_FLAG = &quot;CHANGE_FLAG&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, ?&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Optional&lt;String&gt; getValue(String definition, String key) &#123;</span><br><span class="line">        if (isEmpty(definition) || isEmpty(key))</span><br><span class="line">            return Optional.empty();</span><br><span class="line">        Map&lt;String, String&gt; key2ValueMap = DEFINITION_TO_KEY_VALUE_MAP.get(definition);</span><br><span class="line">        return isNull(key2ValueMap) ? Optional.empty() : Optional.ofNullable(key2ValueMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateKeyValueMap(String definition) &#123;</span><br><span class="line">        if (isEmpty(definition))</span><br><span class="line">            return;</span><br><span class="line">        //1.获取redis更新标志和本地更新标志</span><br><span class="line">        String redisChangeFlag = this.getRedisChangeFlag(definition);</span><br><span class="line">        String localChangeFlag = this.getLocalChangeFlag(definition);</span><br><span class="line">        //2.redis更新标志为空，则从数据库获取数据并分别推送到redis和应用内存，注意缓存击穿、缓存穿透和缓存雪崩的情况</span><br><span class="line">        if (isEmpty(redisChangeFlag)) &#123;</span><br><span class="line">            this.deleteByKey(definition);</span><br><span class="line">            this.getAndPutAllData(definition);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //3.如果不相等，则从redis拉取数据并保存到应用内存</span><br><span class="line">        if (!redisChangeFlag.equals(localChangeFlag)) &#123;</span><br><span class="line">            Map&lt;String, String&gt; key2ValueMap = redisTemplate.opsForHash()</span><br><span class="line">                    .entries(definition).entrySet().stream()</span><br><span class="line">                    .collect(Collectors.toMap(entry -&gt; objectToString(entry.getKey()),</span><br><span class="line">                            entry -&gt; objectToString(entry.getValue())));</span><br><span class="line">            DEFINITION_TO_KEY_VALUE_MAP.put(definition, key2ValueMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取redis的更新标志</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     * @return redis的更新标志</span><br><span class="line">     */</span><br><span class="line">    private String getRedisChangeFlag(String definition) &#123;</span><br><span class="line">        Object o = redisTemplate.opsForHash().get(definition, CHANGE_FLAG);</span><br><span class="line">        return StringUtil.objectToString(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取本地更新标志</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     * @return 本地的更新标志</span><br><span class="line">     */</span><br><span class="line">    private String getLocalChangeFlag(String definition) &#123;</span><br><span class="line">        Map&lt;String, String&gt; key2ValueMap = DEFINITION_TO_KEY_VALUE_MAP.get(definition);</span><br><span class="line">        return isNull(key2ValueMap) ? null : key2ValueMap.get(CHANGE_FLAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过语言定义删除数据</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     */</span><br><span class="line">    private void deleteByKey(String definition) &#123;</span><br><span class="line">        redisTemplate.delete(definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取与推送翻译数据</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     * @return 翻译数据</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, String&gt; getAndPutAllData(String definition) &#123;</span><br><span class="line">        //1.从数据库查询翻译数据</span><br><span class="line">        Map&lt;String, String&gt; databaseKeyValueMap = this.getLanguageDataFromDatabase(definition);</span><br><span class="line">        Map&lt;String, String&gt; key2ValueMap = isEmpty(databaseKeyValueMap) ? new ConcurrentHashMap&lt;&gt;()</span><br><span class="line">                : new ConcurrentHashMap&lt;&gt;(databaseKeyValueMap);</span><br><span class="line">        //2.设置更新标志</span><br><span class="line">        key2ValueMap.put(CHANGE_FLAG, UUIDUtil.randomUUID());</span><br><span class="line">        //3.将数据推送到redis</span><br><span class="line">        byte[] byteKey = definition.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        Map&lt;byte[], byte[]&gt; byteMap = key2ValueMap.entrySet().stream()</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        entry -&gt; entry.getKey().getBytes(StandardCharsets.UTF_8),</span><br><span class="line">                        entry -&gt; entry.getValue().getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        redisTemplate.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">            connection.hMSet(byteKey, byteMap);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;);</span><br><span class="line">        Long expire = redisTemplate.getExpire(definition);</span><br><span class="line">        if (expire == null || expire &lt; 300L)</span><br><span class="line">            redisTemplate.expire(definition, ONE_DAY, TimeUnit.SECONDS);</span><br><span class="line">        //4.将数据放到应用内存</span><br><span class="line">        DEFINITION_TO_KEY_VALUE_MAP.put(definition, key2ValueMap);</span><br><span class="line">        return key2ValueMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从数据库获取数据</span><br><span class="line">     * @param definition 语言定义</span><br><span class="line">     * @return 数据</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, String&gt; getLanguageDataFromDatabase(String definition) &#123;</span><br><span class="line">        //TODO 补充从数据库查询的代码</span><br><span class="line">        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        if (Locale.SIMPLIFIED_CHINESE.toLanguageTag().equals(definition)) &#123;</span><br><span class="line">            map.put(&quot;test.key1&quot;, &quot;这是第一个值&quot;);</span><br><span class="line">            map.put(&quot;test.key2&quot;, &quot;这是第二个值&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(&quot;test.key1&quot;, &quot;the first value&quot;);</span><br><span class="line">            map.put(&quot;test.key2&quot;, &quot;the second value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-将替换逻辑嵌入spring的filter或者序列化"><a href="#2-3-将替换逻辑嵌入spring的filter或者序列化" class="headerlink" title="2-3.将替换逻辑嵌入spring的filter或者序列化"></a>2-3.将替换逻辑嵌入spring的filter或者序列化</h5><p>笔者在这里只演示简单的key-&gt;value替换，至于递归替换、正则替换可以自行考虑加上。</p>
<ul>
<li>2-3-1.当一个请求进来的时候，首先需要做一些前置处理。<ul>
<li>2-3-1-1.根据请求的语言设置当前线程的语言环境。</li>
<li>2-3-1-2.更新一次当前应用内存的语言缓存数据。</li>
</ul>
</li>
<li>2-3-2.当返回响应的时候，通过序列化对响应数据进行替换。</li>
</ul>
<p>代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  @description: 语言对象</span><br><span class="line"> *  @author: rookie0peng</span><br><span class="line"> *  @date: 2021/1/18 17:17</span><br><span class="line"> *  &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">public class Language &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 语言编码, 默认中文简体</span><br><span class="line">     */</span><br><span class="line">    private String localeTag;</span><br><span class="line"></span><br><span class="line">    public Language() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Language(String localeTag) &#123;</span><br><span class="line">        this.localeTag = localeTag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLocaleTag() &#123;</span><br><span class="line">        return localeTag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLocaleTag(String localeTag) &#123;</span><br><span class="line">        this.localeTag = localeTag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Language&#123;&quot; +</span><br><span class="line">                &quot;localeTag=&#x27;&quot; + localeTag + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  @description: 基于线程上下文的语言工具类</span><br><span class="line"> *  @author: rookie0peng</span><br><span class="line"> *  @date: 2021/1/18 17:16</span><br><span class="line"> *  &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">public class LanguageContextUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;Language&gt; CONTEXT = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置语言信息</span><br><span class="line">     * @param language 语言信息</span><br><span class="line">     */</span><br><span class="line">    public static void set(Language language) &#123;</span><br><span class="line">        CONTEXT.set(language);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取语言信息</span><br><span class="line">     * @return 语言信息</span><br><span class="line">     */</span><br><span class="line">    public static Language get() &#123;</span><br><span class="line">        return CONTEXT.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除语言信息</span><br><span class="line">     */</span><br><span class="line">    public static void remove() &#123;</span><br><span class="line">        CONTEXT.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  @description: 语言过滤器</span><br><span class="line"> *  @author: rookie0peng</span><br><span class="line"> *  @date: 2021/1/18 17:16</span><br><span class="line"> *  &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class LanguageFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private LanguageDataComponent languageDataComponent;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.设置当前线程的语言环境</span><br><span class="line">            String localeTag;</span><br><span class="line">            Locale locale = servletRequest.getLocale();</span><br><span class="line">            LanguageContextUtil.set(isNull(locale) || isNull(localeTag = locale.toLanguageTag())</span><br><span class="line">                    ? new Language(Locale.SIMPLIFIED_CHINESE.toLanguageTag()) : new Language(localeTag));</span><br><span class="line">            //2.更新语言数据</span><br><span class="line">            languageDataComponent.updateKeyValueMap(LanguageContextUtil.get().getLocaleTag());</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            LanguageContextUtil.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  @description: i18n序列化</span><br><span class="line"> *  @author: rookie0peng</span><br><span class="line"> *  @date: 2021/7/4 21:28</span><br><span class="line"> *  &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">public class I18nJsonSerializer&lt;T&gt; extends JsonSerializer&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void serialize(T t, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;</span><br><span class="line">        //1.获取语言组件</span><br><span class="line">        LanguageDataComponent languageDataComponent = SpringUtil.getBean(LanguageDataComponent.class);</span><br><span class="line">        //2.通过 语言标志 和 键 获取对应的 值</span><br><span class="line">        Optional&lt;String&gt; valueOptional = languageDataComponent.getValue(LanguageContextUtil.get().getLocaleTag(),</span><br><span class="line">                StringUtil.objectToString(t));</span><br><span class="line">        //3.写入流</span><br><span class="line">        if (valueOptional.isPresent())</span><br><span class="line">            jsonGenerator.writeString(valueOptional.get());</span><br><span class="line">        else</span><br><span class="line">            jsonGenerator.writeString(StringUtil.objectToString(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestTranslateVO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -273426001439788094L;</span><br><span class="line"></span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定i18n序列化类</span><br><span class="line">     */</span><br><span class="line">    @JsonSerialize(using = I18nJsonSerializer.class)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public TestTranslateVO() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TestTranslateVO(String code, String name) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;TestTranslateVO&#123;&quot; +</span><br><span class="line">                &quot;code=&#x27;&quot; + code + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  @description: 通过接口测试i18n</span><br><span class="line"> *  @author: rookie0peng</span><br><span class="line"> *  @date: 2021/1/20 13:07</span><br><span class="line"> *  &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;测试接口-作者:rookie0peng&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;test&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;随便打印数据&quot;)</span><br><span class="line">    @RequestMapping(path = &quot;console&quot;, method = RequestMethod.POST)</span><br><span class="line">    public Map&lt;String, String&gt; console() &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //1.测试无参替换</span><br><span class="line">        map.put(&quot;test.name&quot;, messageSource.getMessage(&quot;test.name&quot;, null, LocaleContextHolder.getLocale()));</span><br><span class="line">        //2.测试字符串参数替换</span><br><span class="line">        Object[] stringParam = new Object[] &#123;&quot;1&quot;&#125;;</span><br><span class="line">        map.put(&quot;test.string&quot;, messageSource.getMessage(&quot;test.string&quot;, stringParam, LocaleContextHolder.getLocale()));</span><br><span class="line">        //3.测试日期参数替换</span><br><span class="line">        Object[] dateParam = new Object[] &#123;new Date()&#125;;</span><br><span class="line">        map.put(&quot;test.date&quot;, messageSource.getMessage(&quot;test.date&quot;, dateParam, LocaleContextHolder.getLocale()));</span><br><span class="line">        //3.测试时间参数替换</span><br><span class="line">        Object[] timeParam = new Object[] &#123;new Date()&#125;;</span><br><span class="line">        map.put(&quot;test.time&quot;, messageSource.getMessage(&quot;test.time&quot;, timeParam, LocaleContextHolder.getLocale()));</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;测试自定义i18n&quot;)</span><br><span class="line">    @RequestMapping(path = &quot;test/custom-i18n&quot;, method = RequestMethod.POST)</span><br><span class="line">    public List&lt;TestTranslateVO&gt; testCustomI18n() &#123;</span><br><span class="line">        //test.key1和test.key2在LanguageDataComponentImpl.getLanguageDataFromDatabase方法中定义了</span><br><span class="line">        //test.key3用来测试不翻译的场景</span><br><span class="line">        return ListUtil.newArrayList(</span><br><span class="line">                new TestTranslateVO(&quot;test.key1&quot;, &quot;test.key1&quot;),</span><br><span class="line">                new TestTranslateVO(&quot;test.key2&quot;, &quot;test.key2&quot;),</span><br><span class="line">                new TestTranslateVO(&quot;test.key3&quot;, &quot;test.key3&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-测试自定义i18n"><a href="#2-4-测试自定义i18n" class="headerlink" title="2-4.测试自定义i18n"></a>2-4.测试自定义i18n</h5><p>启动项目后，查看调用<strong>test&#x2F;custom-i18n</strong>接口返回的数据，调用三次，分别设置header中的语言：默认、中文、英文。<br>笔者用的是idea的HTTP Client，以下是请求参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 默认——测试自定义i18n</span><br><span class="line">POST &#123;&#123;baseUrl&#125;&#125;/test/test/custom-i18n</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 中文——测试自定义i18n</span><br><span class="line">POST &#123;&#123;baseUrl&#125;&#125;/test/test/custom-i18n</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 英文——测试自定义i18n</span><br><span class="line">POST &#123;&#123;baseUrl&#125;&#125;/test/test/custom-i18n</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept-Language: en;q=0.9</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是返回参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key1&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;这是第一个值&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key2&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;这是第二个值&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key3&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;test.key3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key1&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;这是第一个值&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key2&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;这是第二个值&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key3&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;test.key3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key1&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;the first value&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key2&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;the second value&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;test.key3&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;test.key3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="2-5-分析执行结果"><a href="#2-5-分析执行结果" class="headerlink" title="2-5.分析执行结果"></a>2-5.分析执行结果</h5><ul>
<li>2-5-1.<strong>测试默认</strong>和<strong>测试中文</strong>的响应数据是一样的，可以确定系统默认使用的中文环境。</li>
<li>2-5-2.对于使用了@JsonSerialize(using &#x3D; I18nJsonSerializer.class)注解的属性，会根据key自动替换成对应的值。</li>
<li>2-5-3.根据key没找到值时，还是会使用原本的key。</li>
</ul>
<h5 id="2-6-结论"><a href="#2-6-结论" class="headerlink" title="2-6.结论"></a>2-6.结论</h5><p>这里只是简单的演示了自定义i18n的功能，但是已然支持用户新增语言、自定义翻译后的值、多机部署等。如果想要支持正则替换、递归翻译也可以自行扩展。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>这里演示了两种i18n的实现方案，具体想用哪种就见仁见智了。图方便，开箱即用，那就选spring i18n；图灵活，可扩展性强，那就选自定义i18n。自然，肯定还有很多我没想到的方案，如果可以的话，欢迎大家在评论区指点。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[1] <a href="https://www.w3.org/International/questions/qa-i18n">“Localization vs. Internationalization”.W3C</a></li>
</ul>
<p>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
